<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8"/>
	<meta name="viewport" content="initial-scale=1.0,maximum-scale=1.0" />
	<title>__FNAME__ – Page Analyis</title>
	<link rel="stylesheet" type="text/css" href="../style.css">
</head>
<body>
	<nav class="small">
		<a href="../index.html" class="home"></a>
		<a href="#top">Top</a>
		<a href="#count">Count</a>
		<a href="#double-rune">Double-Rune</a>
		<a href="#ioc">IoC</a>
		<a href="#mod-ioc">Mod-IoC</a>
		<a href="#pattern-ioc">Pattern-IoC</a>
		<a href="#running-ioc">Running-IoC</a>
		<a href="#concealment">Concealment</a>
	</nav>
	<h1 id="top">Page Analysis: __FNAME__</h1>
	<h2 id="count">Count</h2>
	__SEC_COUNTS__

	<h2 id="double-rune">Double-Rune Occurrence</h2>
	<p>
		The following analysis looks at two neighboring runes.
		Whenever two identical runes appear one after another, the number sequence will print a “1” on dark background.
		Rune difference looks at the shortest distance between two neighbors.
		Maximum value is 14 if they are farthest apart.
		The value is zero if they are identical.
	</p>
	<p>
		<b>Note:</b> Hover on a cell to see the offset in the file.
	</p>
	__SEC_DOUBLE__
	
	<h2 id="ioc">Index of Coincidence (IoC)</h2>
	<p>
		Quick IoC recap: Normal english IoC is about 1.77.
		Values below 1.4 are highly unlikely to be anywhat meaningful.
		Predicting english text with IoC gets worse if the text is very short.
	</p>
	<p>
		Here we are considering to either ᚠ being an interrupt; or it's inverse ᛠ.
		The numbers (1–32) represent the key length.
		With a key length of 5, every fifth rune will be decrypted with the same alphabet.
	</p>
	<p>
		<b>Note:</b> the darker the cell, the better the prediction.
		The runes per length columns influences the results of the other columns; so if this is low, the other columns are not reliable.
	</p>
	__SEC_IOC__

	<h2 id="mod-ioc">Modulo IoC</h2>
	<p>
		This section explores the idea of multiple alphabet-sets alternating.
		For example, have two or three Vigenere ciphers that switch after each rune.
		A Vigenere with key length 3 (ABC) plus another Vigenere with key length 5 (DEFGH) will generate a pattern that only repeats after 30 runes (ADBECFAGBHCDAEBFCGAHBDCEAFBGCH).
		So the first group will represent every 2nd rune starting with the first, and the second group will contain every 2nd rune starting with the second.
	</p>
	<p>
		There are two main distinctions.
		Interrupt-first-then-mod assumes that an interrupt will pause the alternation between the different groups.
		Mod-first-then-interrupt assumes that an interrupt will pause the key alternation within that group.
		Lets look at the example Vig(3) + Vig(5).
		With the first, the decryption sequence is: Vig(3)[0], interrupt, Vig(5)[0], Vig(3)[1], etc.
		With the second, the decryption sequence is: Vig(3)[0], interrupt, Vig(3)[1], Vig(5)[0], etc.
		Note that the second decryption still switched to Vig(5) but was ignored because it was an interrupt.
	</p>
	<p>
		<b>Note:</b> The row header format is {interrupt}.{mod}.{offset}.
		“ᚠ.2.0” means, assume the interrupt is ᚠ, divide the data into two sets, then look at the first set (rune at index 0, rune at index 2, etc.).
		The column shows the keylength for which the IoC was calculated.
		In the previous example, with a key length of 7, indices 0, 14, 28, ... are part of one alphabet, and indices 2, 17, 30, ... are part of another alphabet.
	</p>
	__SEC_IOC_MOD__

	<h2 id="pattern-ioc">Pattern IoC</h2>
	<p>
		This section looks at different ways to extend a short key into a longer one. The result of the expansion is still a plain Vigenere-like encryption but the key is so long that we would not be able to find it with IoC analysis. However, we can use the fact that the same letters appear again and so there are less alphabets than the key length.
	</p>
	<p>
		The two mirror pattern variants simply flip the key in reverse and append it to the original key. For example, the key ABCD will become ABCDDCBA (Variant A) or ABCDCB (Variant B). Both keys will repeat after that. Notice how the first variant will produce double letters (DD and AA) and the second not.
	</p>
	<p>
		The shift pattern simply offsets the key by one and appends this permutation to the key. For example, ABCD becomes ABCDBCDACDABDABC. Each key length n (here 4) has n - 1 shifts. The example before was shift = 1. The other two are ABCDCDAB (shift=2) and ABCDDABCCDABBCDA (shift=3). And again, like with the mirror pattern, we greatly increase the key length without increasing the alphabet count.
	</p>
	<p>
		<b>Note:</b> while the column in the mirror pattern represents the key length, the column in the shift pattern is <b>not</b> the key length. Instead, the key length is given in the row title, e.g., “ᚠ.5”. The column header represents the key shift variation.
	</p>
	__SEC_IOC_PATTERN__

	<h2 id="running-ioc">Running IoC</h2>
	<p>
		This section perfoms a running IoC with a window size on the whole text.
		For example, a window size of 50 will look at the first 50 runes and calculate the IoC (high).
		This will be the first value in the list.
		The text is offsetted by one and the next 50 runes are evaluated.
		This contiunes to the last set of 50 runes.
	</p>
	<p>
		Same rules apply as to normal IoC; an IoC on 20 runes is just too small to get a meaningful result.
		But it helps to get the bigger picture ;).
	</p>
	__SEC_IOC_FLOW__

	<h2 id="concealment">Concealment Analysis</h2>
	<p>
		Concealment ciphers hide text in plain sight. Here we look at every n-th word, as well as every first and last letter of each word. That is performed on all possible veriations. The numbers inside the parenthesis are the IoC analysis on the selected text as high / norm.
	</p>
	__SEC_CONCEAL__

</body>
</html>